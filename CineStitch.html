<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CineStitch 电影拼图工具</title>
    <!-- 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 引入 Babel 来转换 JSX/ES6 -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 引入 Tailwind CSS 样式 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 移除了 Lucide Icons 库的引用，改为内联 SVG -->

    <style>
        /* 自定义滚动条样式，用于图片列表 */
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: #3f3f46; /* zinc-700 */
            border-radius: 20px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #18181b; /* zinc-900 */
        }
        /* 保持 SVG 图标的显示样式 */
        .svg-icon {
            display: inline-block;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
    </style>
</head>
<body class="bg-zinc-950">

    <!-- 这是 React 应用的挂载点 -->
    <div id="root"></div>

    <script type="text/babel">
        // 确保所有 React 代码在 Babel 脚本标签内
        
        // --- Icon Components (Inline SVGs to fix the "Element type is invalid" error) ---
        
        const SvgIcon = ({ children, size = 24, className = '', ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                className={`svg-icon ${className}`} 
                {...props}
            >
                {children}
            </svg>
        );

        const Upload = (props) => (
            <SvgIcon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></SvgIcon>
        );
        const Download = (props) => (
            <SvgIcon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></SvgIcon>
        );
        const ImageIcon = (props) => (
            <SvgIcon {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></SvgIcon>
        );
        const Settings = (props) => (
            <SvgIcon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-.44 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 .44H2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 2 .44v.44a2 2 0 0 0 2 2h.44a2 2 0 0 1 .44 2v.44a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 .44-2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-.44H22v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-2-.44v-.44a2 2 0 0 0-2-2h-.44a2 2 0 0 1-.44-2V4a2 2 0 0 0-2-2zm0 10a4 4 0 1 1 0 8 4 4 0 0 1 0-8z"/></SvgIcon>
        );
        const MoveVertical = (props) => (
            <SvgIcon {...props}><polyline points="8 18 12 22 16 18"/><polyline points="8 6 12 2 16 6"/><line x1="12" x2="12" y1="2" y2="22"/></SvgIcon>
        );
        const Trash2 = (props) => (
            <SvgIcon {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></SvgIcon>
        );
        const ArrowUp = (props) => (
            <SvgIcon {...props}><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></SvgIcon>
        );
        const ArrowDown = (props) => (
            <SvgIcon {...props}><path d="M12 5v14"/><path d="m19 12-7 7-7-7"/></SvgIcon>
        );

        const CineStitch = () => {
            // 使用 React Hooks (useState, useRef, useEffect, useCallback)
            const [images, setImages] = React.useState([]);
            const [settings, setSettings] = React.useState({
                aspectRatio: 2.35, // 2.35:1 CinemaScope
                outputWidth: 2500, // High res export width
                gap: 50, // Gap between images
                paddingX: 50, // Horizontal padding
                paddingY: 150, // Vertical padding (default larger for cinematic look)
                backgroundColor: '#000000',
                preserveOriginalRatio: false, // If true, ignore aspectRatio
            });
            
            const canvasRef = React.useRef(null);
            const [isDragging, setIsDragging] = React.useState(false);
            const [previewUrl, setPreviewUrl] = React.useState(null);

            // Handle File Upload
            const handleFileUpload = (e) => {
                const files = Array.from(e.target.files);
                processFiles(files);
                // Reset file input value to allow re-uploading the same file if needed
                e.target.value = '';
            };

            const processFiles = (files) => {
                const newImagesPromises = files.map((file) => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                resolve({
                                    id: Math.random().toString(36).substr(2, 9),
                                    file,
                                    src: img.src, // Keep string for UI display (thumbnails)
                                    imgElement: img, // Store actual DOM element for Canvas
                                    width: img.width,
                                    height: img.height,
                                    yOffset: 50, // 0 to 100 percentage for vertical cropping center
                                });
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    });
                });

                Promise.all(newImagesPromises).then((loadedImages) => {
                    setImages((prev) => [...prev, ...loadedImages]);
                });
            };

            // Drag and Drop handlers
            const onDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };
            const onDragLeave = () => setIsDragging(false);
            const onDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                processFiles(Array.from(e.dataTransfer.files));
            };

            // Image Management
            const removeImage = (id) => {
                setImages(images.filter((img) => img.id !== id));
            };

            const moveImage = (index, direction) => {
                const newImages = [...images];
                if (direction === 'up' && index > 0) {
                    [newImages[index], newImages[index - 1]] = [newImages[index - 1], newImages[index]];
                } else if (direction === 'down' && index < newImages.length - 1) {
                    [newImages[index], newImages[index + 1]] = [newImages[index + 1], newImages[index]];
                }
                setImages(newImages);
            };

            const updateImageOffset = (id, newOffset) => {
                setImages(images.map(img => img.id === id ? { ...img, yOffset: newOffset } : img));
            };

            // Canvas Drawing Logic
            const drawCanvas = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                // Clear canvas if no images
                if (images.length === 0) {
                    setPreviewUrl(null);
                    return;
                }

                const ctx = canvas.getContext('2d');
                const { outputWidth, aspectRatio, gap, paddingX, paddingY, backgroundColor } = settings;

                // Calculate dimensions
                // Target height for a single strip based on aspect ratio
                const targetStripHeight = outputWidth / aspectRatio;
                
                // Calculate total canvas height
                // (Height of all strips) + (Gaps between them) + (Top/Bottom padding)
                const totalContentHeight = images.length * targetStripHeight;
                const totalGaps = Math.max(0, images.length - 1) * gap;
                const totalCanvasHeight = totalContentHeight + totalGaps + (paddingY * 2);
                const totalCanvasWidth = outputWidth + (paddingX * 2);

                canvas.width = totalCanvasWidth;
                canvas.height = totalCanvasHeight;

                // Fill background
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let currentY = paddingY;

                images.forEach((img) => {
                    // Ensure we have the image element loaded
                    if (!img.imgElement) return;

                    // Calculate source crop
                    // We want to fit the image width to the output width, 
                    // then crop the height to match aspect ratio.
                    
                    const scale = img.width / outputWidth;
                    const sourceCropHeight = targetStripHeight * scale;
                    
                    // Safety check: if image is too short for the aspect ratio
                    let sy, sh, sw, sx;

                    if (img.height < sourceCropHeight) {
                        // Image is wider/shorter than target aspect ratio (unlikely for cinema crop usually)
                        // We fit height and crop width
                        sh = img.height;
                        sw = img.height * aspectRatio;
                        sy = 0;
                        sx = (img.width - sw) / 2; // Center horizontally
                    } else {
                        // Normal case: Image is taller, we crop height
                        sw = img.width;
                        sh = sourceCropHeight;
                        sx = 0;
                        
                        // Calculate Y offset based on user slider (0-100%)
                        const maxScroll = img.height - sh;
                        sy = maxScroll * (img.yOffset / 100);
                    }

                    // Draw Image
                    ctx.drawImage(
                        img.imgElement, // source (HTMLImageElement)
                        sx, sy, sw, sh, // source coords
                        paddingX, currentY, outputWidth, targetStripHeight // dest coords
                    );

                    currentY += targetStripHeight + gap;
                });

                // Create a preview URL for the UI
                try {
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    setPreviewUrl(dataUrl);
                } catch (err) {
                    console.error("Canvas export failed", err);
                }

            }, [images, settings]);

            React.useEffect(() => {
                drawCanvas();
            }, [images, settings, drawCanvas]);

            const handleDownload = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const link = document.createElement('a');
                link.download = `cine-stitch-${Date.now()}.jpg`;
                link.href = canvas.toDataURL('image/jpeg', 1.0);
                link.click();
            };

            return (
                <div className="min-h-screen bg-zinc-950 text-zinc-200 font-sans selection:bg-amber-500/30">
                
                {/* Header */}
                <header className="border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-md sticky top-0 z-50">
                    <div className="max-w-7xl mx-auto px-6 h-16 flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <div className="w-8 h-8 bg-gradient-to-tr from-amber-600 to-yellow-500 rounded-md flex items-center justify-center text-black font-bold">
                        CS
                        </div>
                        <h1 className="text-xl font-medium tracking-wide text-zinc-100">CineStitch <span className="text-xs text-zinc-500 font-normal ml-1">电影拼图工具</span></h1>
                    </div>
                    <button 
                        onClick={handleDownload}
                        disabled={images.length === 0}
                        className={`flex items-center gap-2 px-5 py-2 rounded-full font-medium transition-all ${
                        images.length === 0 
                            ? 'bg-zinc-800 text-zinc-500 cursor-not-allowed' 
                            : 'bg-zinc-100 text-zinc-900 hover:bg-white hover:shadow-lg hover:shadow-amber-500/20'
                        }`}
                    >
                        <Download size={18} />
                        <span>导出图像</span>
                    </button>
                    </div>
                </header>

                <main className="max-w-7xl mx-auto p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                    
                    {/* Left Sidebar: Controls & List */}
                    <div className="lg:col-span-4 space-y-6">
                    
                    {/* Upload Area */}
                    <div 
                        onDragOver={onDragOver}
                        onDragLeave={onDragLeave}
                        onDrop={onDrop}
                        className={`relative border-2 border-dashed rounded-xl transition-all h-32 flex flex-col items-center justify-center text-center cursor-pointer overflow-hidden group ${
                        isDragging ? 'border-amber-500 bg-amber-500/10' : 'border-zinc-800 hover:border-zinc-600 bg-zinc-900'
                        }`}
                    >
                        <input 
                        type="file" 
                        multiple 
                        accept="image/*" 
                        onChange={handleFileUpload} 
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                        />
                        <Upload size={36} className={`mb-2 transition-colors ${isDragging ? 'text-amber-500' : 'text-zinc-500 group-hover:text-zinc-300'}`} />
                        <p className="text-sm text-zinc-400 group-hover:text-zinc-200">
                        点击或拖拽上传图片
                        </p>
                    </div>

                    {/* Settings Panel */}
                    <div className="bg-zinc-900 rounded-xl p-5 border border-zinc-800 shadow-sm">
                        <div className="flex items-center gap-2 mb-4 text-zinc-100 font-medium">
                        <Settings size={18} className="text-amber-500" />
                        <h2>全局设置</h2>
                        </div>
                        
                        <div className="space-y-4">
                        <div>
                            <div className="flex justify-between text-xs text-zinc-400 mb-1">
                            <span>画幅比例 (AspectRatio)</span>
                            <span className="text-amber-500">{settings.aspectRatio}:1</span>
                            </div>
                            <div className="grid grid-cols-3 gap-2">
                            {[2.35, 2.39, 1.78].map((ratio) => (
                                <button
                                    key={ratio}
                                    onClick={() => setSettings({...settings, aspectRatio: ratio})}
                                    className={`text-xs py-1.5 rounded border transition-colors ${
                                    settings.aspectRatio === ratio 
                                        ? 'bg-amber-500/20 border-amber-500 text-amber-500' 
                                        : 'border-zinc-700 hover:border-zinc-500 text-zinc-400'
                                    }`}
                                >
                                <div className="flex justify-center items-center">
                                    {ratio === 1.78 ? '16:9' : `${ratio}:1`}
                                    <div className="w-4 h-2 ml-1 border border-current rounded-sm overflow-hidden relative">
                                        <div 
                                            className="absolute bg-zinc-700/50"
                                            style={{
                                                top: `${50 - 50/ratio}%`,
                                                height: `${100/ratio}%`,
                                                left: 0,
                                                width: '100%',
                                                // Use a visual hint for the ratio
                                                backgroundColor: ratio === settings.aspectRatio ? 'rgba(255, 165, 0, 0.4)' : 'rgba(255, 255, 255, 0.1)',
                                            }}
                                        ></div>
                                    </div>
                                </div>
                                </button>
                            ))}
                            </div>
                        </div>

                        <div>
                            <div className="flex justify-between text-xs text-zinc-400 mb-1">
                            <span>间距 (Gap)</span>
                            <span>{settings.gap}px</span>
                            </div>
                            <input 
                            type="range" 
                            min="0" 
                            max="200" 
                            value={settings.gap} 
                            onChange={(e) => setSettings({...settings, gap: parseInt(e.target.value)})}
                            className="w-full h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                            />
                        </div>

                        <div>
                            <div className="flex justify-between text-xs text-zinc-400 mb-1">
                            <span>上下边距 (Padding Y)</span>
                            <span>{settings.paddingY}px</span>
                            </div>
                            <input 
                            type="range" 
                            min="0" 
                            max="600" 
                            value={settings.paddingY} 
                            onChange={(e) => setSettings({...settings, paddingY: parseInt(e.target.value)})}
                            className="w-full h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                            />
                        </div>

                        <div>
                            <div className="flex justify-between text-xs text-zinc-400 mb-1">
                            <span>左右边距 (Padding X)</span>
                            <span>{settings.paddingX}px</span>
                            </div>
                            <input 
                            type="range" 
                            min="0" 
                            max="300" 
                            value={settings.paddingX} 
                            onChange={(e) => setSettings({...settings, paddingX: parseInt(e.target.value)})}
                            className="w-full h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                            />
                        </div>
                        
                        <div>
                            <div className="flex justify-between text-xs text-zinc-400 mb-1">
                            <span>背景颜色</span>
                            </div>
                            <div className="flex gap-2">
                                {['#000000', '#ffffff', '#1a1a1a', '#2d2d2d'].map(color => (
                                    <button 
                                        key={color}
                                        onClick={() => setSettings({...settings, backgroundColor: color})}
                                        className={`w-6 h-6 rounded-full border ${settings.backgroundColor === color ? 'border-amber-500 scale-110' : 'border-zinc-700'}`}
                                        style={{backgroundColor: color}}
                                    />
                                ))}
                            </div>
                        </div>
                        </div>
                    </div>

                    {/* Image List */}
                    <div className="space-y-3">
                        <div className="flex items-center justify-between text-sm text-zinc-400 px-1">
                        <span>图层顺序 ({images.length})</span>
                        {images.length > 0 && (
                            <button onClick={() => setImages([])} className="text-xs text-red-400 hover:text-red-300">清空全部</button>
                        )}
                        </div>
                        
                        {images.length === 0 && (
                        <div className="text-center py-10 text-zinc-600 text-sm italic">
                            还没有添加图片...
                        </div>
                        )}

                        <div className="max-h-[500px] overflow-y-auto space-y-3 pr-2 scrollbar-thin scrollbar-thumb-zinc-700">
                        {images.map((img, index) => (
                            <div key={img.id} className="bg-zinc-900 border border-zinc-800 rounded-lg p-3 group hover:border-zinc-700 transition-colors">
                            <div className="flex gap-3 mb-3">
                                <div className="w-16 h-12 bg-zinc-800 rounded overflow-hidden flex-shrink-0 relative">
                                    <img src={img.src} alt="thumb" className="w-full h-full object-cover" />
                                </div>
                                <div className="flex-1 min-w-0 flex flex-col justify-center">
                                    <div className="flex items-center justify-between">
                                        <span className="text-xs text-zinc-300 truncate w-32 block">{img.file.name}</span>
                                        <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={() => moveImage(index, 'up')} disabled={index === 0} className="p-1 hover:bg-zinc-800 rounded disabled:opacity-30"><ArrowUp size={14} className="text-zinc-400"/></button>
                                            <button onClick={() => moveImage(index, 'down')} disabled={index === images.length - 1} className="p-1 hover:bg-zinc-800 rounded disabled:opacity-30"><ArrowDown size={14} className="text-zinc-400"/></button>
                                            <button onClick={() => removeImage(img.id)} className="p-1 hover:bg-red-900/30 rounded"><Trash2 size={14} className="text-red-500"/></button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Position Slider */}
                            <div className="space-y-1">
                                <div className="flex justify-between items-center text-[10px] text-zinc-500 uppercase tracking-wider">
                                    <span className="flex items-center gap-1"><MoveVertical size={10}/> 垂直构图位置</span>
                                    <span>{Math.round(img.yOffset)}%</span>
                                </div>
                                <input 
                                    type="range"
                                    min="0"
                                    max="100"
                                    value={img.yOffset}
                                    onChange={(e) => updateImageOffset(img.id, parseInt(e.target.value))}
                                    className="w-full h-1 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                />
                            </div>
                            </div>
                        ))}
                        </div>
                    </div>

                    </div>

                    {/* Right Area: Preview */}
                    <div className="lg:col-span-8 bg-zinc-900 rounded-xl border border-zinc-800 p-8 flex items-start justify-center min-h-[600px] overflow-auto relative">
                    {/* Background Grid Pattern */}
                    <div className="absolute inset-0 opacity-5 pointer-events-none" 
                        style={{backgroundImage: 'radial-gradient(#ffffff 1px, transparent 1px)', backgroundSize: '20px 20px'}}>
                    </div>

                    {images.length > 0 ? (
                        <div className="relative shadow-2xl shadow-black">
                            {/* Visual Preview Image */}
                            {previewUrl && (
                            <img 
                                src={previewUrl} 
                                alt="Collage Preview" 
                                className="max-w-full h-auto max-h-[80vh] object-contain"
                            />
                            )}
                            
                            {/* Hidden Real Canvas */}
                            <canvas ref={canvasRef} className="hidden" />
                        </div>
                    ) : (
                        <div className="flex flex-col items-center justify-center h-full text-zinc-600 space-y-4">
                        <div className="w-20 h-20 rounded-full bg-zinc-800/50 flex items-center justify-center">
                            <ImageIcon size={32} />
                        </div>
                        <p>预览区域将显示拼图结果</p>
                        </div>
                    )}
                    </div>

                </main>

                {/* Footer / Instructions */}
                <footer className="max-w-7xl mx-auto px-6 py-8 text-center text-zinc-600 text-xs">
                    <p>建议上传高清图片以获得最佳效果。 导出尺寸宽度固定为 2500px。</p>
                </footer>
                </div>
            );
        };
        
        // 渲染组件到页面上
        ReactDOM.createRoot(document.getElementById('root')).render(<CineStitch />);
    </script>
</body>
</html>